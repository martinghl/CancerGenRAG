#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
align_priority_ids.py

Normalize / align a priority CSV's IDs to a chosen canonical key (e.g., rsID)
using a crosswalk CSV generated by build_crosswalk_from_pkl.py. Outputs an
"aligned" priority file that you can feed to training for label assignment.

Usage
-----
python align_priority_ids.py \
  --priority-csv data/LC_GWAS_Priority_Scores.csv \
  --priority-id-col variant_id \
  --priority-score-col priority_score \
  --crosswalk-csv outputs/crosswalk.csv \
  --target-key rsID \
  --out-csv outputs/LC_GWAS_Priority_Scores_aligned.csv

What it does
------------
- Reads priority CSV and crosswalk CSV.
- Builds a mapping from any known ID in the crosswalk row to the target_key.
- For each priority row, tries to find the target_key via any matching ID in that row.
- Emits CSV with columns: target_key, priority_score, orig_id, match_key_used
"""
import argparse
from pathlib import Path
from typing import List, Dict

import pandas as pd

def parse_args():
    p = argparse.ArgumentParser(description="Align priority CSV IDs to a target key via crosswalk.")
    p.add_argument("--priority-csv", type=str, required=True)
    p.add_argument("--priority-id-col", type=str, default="variant_id")
    p.add_argument("--priority-score-col", type=str, default="priority_score")
    p.add_argument("--crosswalk-csv", type=str, required=True)
    p.add_argument("--target-key", type=str, default="rsID")
    p.add_argument("--out-csv", type=str, required=True)
    return p.parse_args()

def main():
    args = parse_args()
    prio = pd.read_csv(Path(args.priority_csv))
    if args.priority_id_col not in prio.columns:
        raise ValueError(f"priority id col '{args.priority_id_col}' not found in {args.priority_csv}")
    if args.priority_score_col not in prio.columns:
        raise ValueError(f"priority score col '{args.priority_score_col}' not found in {args.priority_csv}")

    cross = pd.read_csv(Path(args.crosswalk_csv))

    # detect which id columns are present in crosswalk
    id_cols = [c for c in ["hm_rsID","rsID","variant_id","chr","pos"] if c in cross.columns]
    if args.target_key not in id_cols:
        raise ValueError(f"target key '{args.target_key}' not found in crosswalk columns: {id_cols}")

    # Normalize to string for matching
    for c in id_cols:
        cross[c] = cross[c].astype(str).str.strip().str.lower()
    prio["_orig_id"] = prio[args.priority_id_col].astype(str).str.strip().str.lower()

    # Build multi-key lookup: value -> target_key (first valid)
    # If a row has multiple IDs, prefer rows where target_key is non-null
    lut: Dict[str, str] = {}
    cross_valid = cross.dropna(subset=[args.target_key])
    # iterate rows â€“ keep it simple (can optimize if needed)
    for _, r in cross_valid.iterrows():
        tgt = r[args.target_key]
        if pd.isna(tgt) or tgt == "nan":
            continue
        for c in id_cols:
            v = r[c]
            if pd.isna(v) or v == "nan":
                continue
            if v not in lut:
                lut[v] = tgt

    # Map priority IDs via LUT
    prio["_aligned_id"] = prio["_orig_id"].map(lut)
    out = prio.loc[~prio["_aligned_id"].isna(), ["_aligned_id", args.priority_score_col, "_orig_id"]].copy()
    out = out.rename(columns={"_aligned_id": args.target_key, args.priority_score_col: "priority_score", "_orig_id": "orig_id"})
    out["match_key_used"] = args.priority_id_col

    out.to_csv(Path(args.out_csv), index=False)
    print(f"[ok] wrote aligned priority to {args.out_csv}  (rows={len(out)})")
    if len(out) < len(prio):
        print(f"[info] {len(prio) - len(out)} rows did not align; consider enriching crosswalk with more ID columns.")

if __name__ == "__main__":
    main()
